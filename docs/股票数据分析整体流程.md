# 股票数据分析整体流程文档

本文档描述从**用户提交单个股票代码 + 选择报告类型（full/simple）**开始，到**产出报告**的完整链路，包括调用的 API、经过的函数、数据来源、返回结果与执行逻辑。

---

## 一、入口与参数

### 1.1 用户侧

- **入口**：Web 配置页「快速分析」区域。
- **操作**：
  1. 输入股票代码（如 `600519`、`HK00700`、`AAPL`）。
  2. 选择报告类型：**完整报告 (full)** 或 **精简报告 (simple)**。
  3. 可选勾选「强制刷新」。
  4. 点击「分析」按钮。

### 1.2 前端调用

- **函数**：`submitAnalysis()`（定义在 `web/templates.py` 内联 JS 中）。
- **请求**：`GET /analysis?code={股票代码}&report_type={full|simple}&force_refresh=true（可选）`
- **说明**：前端用 `fetch(url)` 调用上述 URL，成功后得到 `task_id`，再通过轮询 `GET /task?id={task_id}` 获取任务状态与结果。

---

## 二、API 与路由

| 项目 | 说明 |
|------|------|
| **路径** | `/analysis` |
| **方法** | GET |
| **注册位置** | `web/router.py` → `create_default_router()` 中注册，handler 为 `api_handler.handle_analysis(q)` |
| **认证** | 若开启登录，`/analysis` 需认证，未登录返回 401 并跳转 `/login` |

---

## 三、请求处理链路

### 3.1 第一层：API 处理器

| 步骤 | 位置 | 说明 |
|------|------|------|
| 1 | `web/handlers.py` → `ApiHandler.handle_analysis(query)` | 解析 query 参数 `code`、`report_type`、`force_refresh` |
| 2 | 校验 `code` | A 股 6 位数字 / 港股 `HK`+5 位数字 / 美股 1–5 位字母（可选 `.XX` 后缀） |
| 3 | 报告类型 | `report_type` 默认 `full`，通过 `ReportType.from_str(report_type_str)` 转成枚举（`ReportType.FULL` / `ReportType.SIMPLE`） |
| 4 | 提交任务 | 调用 `self.analysis_service.submit_analysis(code, report_type=..., force_refresh=...)` |
| 5 | 返回 | `JsonResponse`：`{ success, message, code, task_id, report_type }` |

### 3.2 第二层：分析任务服务（异步执行）

| 步骤 | 位置 | 说明 |
|------|------|------|
| 1 | `web/services.py` → `AnalysisService.submit_analysis(code, report_type, force_refresh)` | 生成 `task_id`（如 `600519_20260201_123456_789`） |
| 2 | 提交线程池 | `self.executor.submit(self._run_analysis, code, task_id, report_type, None, force_refresh)` |
| 3 | 立即返回 | 返回 `{ success: true, code, task_id, report_type }`，**不等待分析结束** |

实际分析在后台线程中执行：`_run_analysis(code, task_id, report_type, source_message, force_refresh)`。

---

## 四、核心分析流水线（单只股票）

`_run_analysis` 内会：

1. 初始化任务状态（`web/services.py` 里 `self._tasks[task_id]`：status=running, progress, current_step 等）。
2. 延迟导入并创建 `StockAnalysisPipeline`（`src/core/pipeline.py`），配置来自 `get_config()`。
3. 调用 **`pipeline.process_single_stock(code, skip_analysis=False, single_stock_notify=True, report_type=report_type, progress_callback=..., force_refresh=force_refresh)`**。

下面按 **`process_single_stock`** 的执行顺序说明。

---

## 五、`process_single_stock` 执行逻辑

**位置**：`src/core/pipeline.py` → `StockAnalysisPipeline.process_single_stock`

### 5.1 历史缓存（可选）

- **条件**：未 `force_refresh`、启用分析历史（`analysis_history.is_history_enabled()`）、且当日已有成功分析缓存（`has_cached_analysis(code, today)`）。
- **逻辑**：`load_cached_analysis(code, today, report_type=report_type.value)` 从目录 `analysis_history/{日期}/{code}/` 读取 `report_{simple|full}.txt` 和结果；若有且 `single_stock_notify`，则用 `notifier.send(report_content)` 推送后直接返回，**不再拉数据、不再跑 AI**。
- **数据来源**：本地目录 `analysis_history/`（见 `src/analysis_history.py`）。

### 5.2 Step 1：获取并保存日线数据

| 项目 | 说明 |
|------|------|
| **函数** | `pipeline.fetch_and_save_stock_data(code, force_refresh=force_refresh)` |
| **断点续传** | 若未 `force_refresh` 且 `db.has_today_data(code, today)` 为 True，直接返回成功，不请求网络。 |
| **数据获取** | `self.fetcher_manager.get_daily_data(code, days=config.daily_data_days)` |
| **数据来源** | `data_provider.DataFetcherManager`：按优先级依次尝试 Efinance、Akshare、Tushare、Pytdx、Baostock、Yfinance，返回 `(DataFrame, 数据源名称)`。 |
| **落盘** | `save_daily_data_to_history(df, code, source_name)` → 写入 `analysis_history/{日期}/{code}/data/daily_{数据源}.csv`（若启用）；`db.save_daily_data(df, code, source_name)` → 写入 **SQLite**（`storage.py` 的 `StockDaily` 表）。 |

### 5.3 Step 2：单只股票分析 `analyze_stock(code)`

**函数**：`pipeline.analyze_stock(code, progress_callback=...)`（`src/core/pipeline.py`）

内部按顺序执行：

#### 5.3.1 获取实时行情

- **调用**：`self.fetcher_manager.get_realtime_quote(code)`
- **数据来源**：`DataFetcherManager` 按配置优先级（如 efinance、akshare_em、sina、tencent 等）故障切换，返回量比、换手率、价格等；美股走 Yfinance。
- **用途**：股票名称、价格、量比、换手率等写入后续「增强上下文」，并参与通知/报告展示。

#### 5.3.2 获取筹码分布（可选）

- **调用**：`self.fetcher_manager.get_chip_distribution(code)`
- **数据来源**：由 DataFetcherManager 内支持筹码的数据源提供，带熔断保护。
- **用途**：获利比例、集中度等写入增强上下文，供 AI 与报告使用。

#### 5.3.3 趋势分析

- **调用**：`self.db.get_analysis_context(code)` 得到 `context`；若 `context` 中含 `raw_data`，则 `pd.DataFrame(context['raw_data'])` 后调用 `self.trend_analyzer.analyze(df, code)`。
- **说明**：当前 `storage.get_analysis_context()` 只返回最近 2 日的今日/昨日对比，**不包含** `raw_data`；若后续扩展在 context 中注入多日 `raw_data`，则会进行 MA/趋势/买入信号等分析。
- **结果**：`TrendAnalysisResult`（趋势状态、均线、量能、买入信号等）写入增强上下文。

#### 5.3.4 多维度情报搜索（新闻/风险/业绩）

- **条件**：`self.search_service.is_available`（配置了 Tavily/SerpAPI 等 Key）。
- **调用**：`self.search_service.search_comprehensive_intel(stock_code=code, stock_name=stock_name, max_searches=5)`。
- **数据来源**：Tavily API 或 SerpAPI，多维度（最新消息、风险排查、业绩预期等）。
- **结果**：`search_service.format_intel_report(intel_results, stock_name)` 得到 `news_context` 文本，传给 AI 作为「新闻/情报」上下文。

#### 5.3.5 获取分析上下文（技术面）

- **调用**：`self.db.get_analysis_context(code)`（同上）。
- **数据来源**：**SQLite**（`storage.py`）— 从 `StockDaily` 表取最近 2 条记录，组装 `today`、`yesterday`、涨跌幅、量比、均线形态等。
- **返回**：`context` 字典（code, date, today, yesterday, volume_change_ratio, price_change_ratio, ma_status 等）。

#### 5.3.6 增强上下文

- **调用**：`self._enhance_context(context, realtime_quote, chip_data, trend_result, stock_name)`。
- **作用**：把实时行情、筹码、趋势分析、股票名称等合并进 `context`，供 AI 使用。

#### 5.3.7 AI 分析

- **调用**：`self.analyzer.analyze(enhanced_context, news_context=news_context)`。
- **位置**：`src/analyzer.py` → `GeminiAnalyzer.analyze()`（或 OpenAI 兼容 API）。
- **API**：  
  - **Gemini**：`genai.GenerativeModel`，`model.generate_content(prompt, generation_config=..., request_options={"timeout": 120})`。  
  - **OpenAI 兼容**：当 Gemini 不可用或失败时，可切换为 OpenAI 兼容接口（`client.chat.completions.create` 等）。
- **输入**：`_format_prompt(context, name, news_context)` 生成的 prompt（技术面 + 新闻）。
- **输出**：解析 JSON 得到 `AnalysisResult`（评分、操作建议、趋势预测、摘要、dashboard 等），并写回 `raw_response`、`llm_prompt` 等。

### 5.4 分析成功后：写历史 + 按报告类型生成并推送

- **写历史**：若启用分析历史且 `result` 与 `run_data` 存在，调用 `save_analysis_history(...)`（`src/analysis_history.py`），写入：
  - `analysis_history/{日期}/{code}/meta.json`
  - `data/daily.json`, `realtime.json`, `chip.json`, `trend.json`, `data/intel.txt`
  - `report_simple.txt`、`report_full.txt`（按类型）
  - `llm/request.json`、`llm/response.json`

- **报告生成与推送**：  
  - **report_type == ReportType.FULL**：`report_content = self.notifier.generate_dashboard_report([result])`（`src/notification.py`，决策仪表盘格式）。  
  - **report_type == ReportType.SIMPLE**：`report_content = self.notifier.generate_single_stock_report(result)`（单股精简报告）。  
  然后 `self.notifier.send(report_content)`：
  - 先 `send_to_context(content)`（飞书/钉钉等 Bot 会话内回复，若有 source_message）。
  - 再根据配置向已启用渠道发送：企业微信、飞书、Telegram、邮件、Pushover、Pushplus、Discord、AstrBot 等（见 `notification.py` 的 `send()`）。

### 5.5 任务状态回写

- 在 `web/services.py` 的 `_run_analysis` 中，通过 `progress_callback` 更新 `self._tasks[task_id]` 的 `progress`、`current_step`（如 data_fetch、realtime、chip、trend、news_search、prepare_ai 等）。
- 分析成功：更新任务为 `status=completed`，写入 `result`（按 report_type 返回完整或精简字段）、`from_cache`、`report_generated_at`。
- 分析失败：更新为 `status=failed`，写入 `error`。

---

## 六、报告类型与报告内容

| 报告类型 | 枚举 | 生成函数 | 说明 |
|----------|------|----------|------|
| **完整报告 (full)** | `ReportType.FULL` | `NotificationService.generate_dashboard_report([result])` | 决策仪表盘：市场概览、重要信息、核心结论、数据透视、作战计划等，多段式 Markdown。 |
| **精简报告 (simple)** | `ReportType.SIMPLE` | `NotificationService.generate_single_stock_report(result)` | 单股精简：核心结论、重要信息、操作建议等，适合单股即时推送。 |

两者都基于同一份 `AnalysisResult`，只是排版与详略不同；报告内容通过 `notifier.send()` 发往配置的渠道（含 Bot 会话）。

---

## 七、数据来源汇总

| 数据类型 | 来源 | 获取方式 / 函数 |
|----------|------|------------------|
| 日线 K 线 | Efinance / Akshare / Tushare / Pytdx / Baostock / Yfinance | `DataFetcherManager.get_daily_data()`，故障切换 |
| 今日是否已有数据 | SQLite | `DatabaseManager.has_today_data(code, today)` |
| 分析用技术面上下文 | SQLite（StockDaily 最近 2 条） | `DatabaseManager.get_analysis_context(code)` |
| 实时行情 | 各数据源实时接口（按配置优先级） | `DataFetcherManager.get_realtime_quote(code)` |
| 筹码分布 | 支持筹码的数据源 | `DataFetcherManager.get_chip_distribution(code)` |
| 新闻/情报 | Tavily / SerpAPI | `SearchService.search_comprehensive_intel()` → `format_intel_report()` |
| AI 分析 | Gemini API / OpenAI 兼容 API | `GeminiAnalyzer.analyze()` → `_call_api_with_retry()` |
| 历史缓存与报告落盘 | 本地目录 + SQLite | `analysis_history` 模块 + `DatabaseManager.save_daily_data()` |

---

## 八、返回结果汇总

| 阶段 | 返回内容 |
|------|----------|
| **GET /analysis** | `{ success: true, message, code, task_id, report_type }`（任务已提交，异步执行） |
| **GET /task?id=xxx** | `{ success: true, task: { task_id, code, status, progress, current_step, result?, error?, report_type, from_cache?, report_generated_at? } }`；`result` 结构依 report_type 为完整或精简字段。 |
| **推送** | 报告正文以 Markdown 形式发送到配置的钉钉/飞书/企业微信等渠道及 Bot 会话。 |
| **本地** | 报告与元数据写入 `analysis_history/{日期}/{code}/`，日线写入 SQLite 与可选 CSV 历史。 |

---

## 九、流程简图（单股 + 选报告类型）

```
用户输入 code + report_type(full/simple) + force_refresh(可选)
    → submitAnalysis() → GET /analysis?code=...&report_type=...&force_refresh=...
    → ApiHandler.handle_analysis(query)
    → AnalysisService.submit_analysis(code, report_type, force_refresh)
    → 返回 { task_id }，后台线程 _run_analysis()
        → StockAnalysisPipeline(config).process_single_stock(code, report_type=..., force_refresh=...)
            → [可选] 历史缓存命中 → 直接加载 report_{simple|full}.txt → notifier.send() → 结束
            → fetch_and_save_stock_data() → DataFetcherManager.get_daily_data() → db.save_daily_data() / save_daily_data_to_history()
            → analyze_stock(code)
                → get_realtime_quote() → get_chip_distribution() → get_analysis_context() + 趋势(若 raw_data) → search_comprehensive_intel()
                → _enhance_context() → analyzer.analyze(enhanced_context, news_context)  [Gemini/OpenAI]
            → save_analysis_history() 写目录 + report_simple.txt / report_full.txt
            → report_type==FULL ? generate_dashboard_report([result]) : generate_single_stock_report(result)
            → notifier.send(report_content)
        → 更新 _tasks[task_id] 为 completed，写入 result
前端轮询 GET /task?id=task_id → 展示状态与 result；用户在各渠道收到报告。
```

---

以上即从「用户提交单只股票代码 + 选择 full/simple 报告」到「调用 API、走到的函数、数据从哪来、结果如何返回、执行逻辑、直至出报告」的完整流程说明。
